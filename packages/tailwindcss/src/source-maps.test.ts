import MagicString from 'magic-string'
import { SourceMapConsumer, type RawSourceMap } from 'source-map-js'
import { expect, test } from 'vitest'
import { compile } from '.'

function run(rawCss: string, candidates: string[] = []) {
  let str = new MagicString(rawCss)
  let originalMap: RawSourceMap = JSON.parse(
    str
      .generateMap({
        hires: 'boundary',
        source: 'input.css',
        includeContent: true,
      })
      .toString(),
  )

  let compiler = compile(str.toString(), { map: originalMap })

  let css = compiler.build(candidates)
  let map = compiler.buildSourceMap()
  let sources = map.sources
  let annotations = annotatedMappings(map)

  return { css, map, sources, annotations }
}

test('utilities have source maps pointing to the utilities node', async () => {
  let { sources, annotations } = run(`@tailwind utilities;`, [
    //
    'underline',
  ])

  // All CSS generated by Tailwind CSS should be annotated with source maps
  // And always be able to point to the original source file
  expect(sources).toEqual(['input.css'])
  expect(sources.length).toBe(1)

  expect(annotations).toEqual([
    //
    '1:0 <- 1:0',
    '2:2 <- 1:0',
  ])
})

test('@apply generates source maps', async () => {
  let { sources, annotations } = run(`.foo {
  color: blue;
  @apply text-[#000] hover:text-[#f00];
  @apply underline;
  color: red;
}`)

  // All CSS generated by Tailwind CSS should be annotated with source maps
  // And always be able to point to the original source file
  expect(sources).toEqual(['input.css'])
  expect(sources.length).toBe(1)

  expect(annotations).toEqual([
    //
    '1:0 <- 1:0',
    '2:2 <- 2:2',
    '3:2 <- 3:2',
    '4:2 <- 3:2',
    '5:4 <- 3:2',
    '7:2 <- 4:2',
    '8:2 <- 5:2',
  ])
})

/**
 * An string annotation that represents a source map
 *
 * It's not meant to be exhaustive just enough to
 * verify that the source map is working and that
 * lines are mapped back to the original source
 *
 * Including when using @apply with multiple classes
 */
function annotatedMappings(map: RawSourceMap) {
  const smc = new SourceMapConsumer(map)
  const annotations: Record<
    number,
    {
      original: { start: [number, number]; end: [number, number] }
      generated: { start: [number, number]; end: [number, number] }
    }
  > = {}

  smc.eachMapping((mapping) => {
    let annotation = (annotations[mapping.generatedLine] = annotations[mapping.generatedLine] || {
      ...mapping,

      original: {
        start: [mapping.originalLine, mapping.originalColumn],
        end: [mapping.originalLine, mapping.originalColumn],
      },

      generated: {
        start: [mapping.generatedLine, mapping.generatedColumn],
        end: [mapping.generatedLine, mapping.generatedColumn],
      },
    })

    annotation.generated.end[0] = mapping.generatedLine
    annotation.generated.end[1] = mapping.generatedColumn

    annotation.original.end[0] = mapping.originalLine
    annotation.original.end[1] = mapping.originalColumn
  })

  return Object.values(annotations).map((annotation) => {
    return `${formatRange(annotation.generated)} <- ${formatRange(annotation.original)}`
  })
}

function formatRange(range: { start: [number, number]; end: [number, number] }) {
  if (range.start[0] === range.end[0]) {
    // This range is on the same line
    // and the columns are the same
    if (range.start[1] === range.end[1]) {
      return `${range.start[0]}:${range.start[1]}`
    }

    // This range is on the same line
    // but the columns are different
    return `${range.start[0]}:${range.start[1]}-${range.end[1]}`
  }

  // This range spans multiple lines
  return `${range.start[0]}:${range.start[1]}-${range.end[0]}:${range.end[1]}`
}
